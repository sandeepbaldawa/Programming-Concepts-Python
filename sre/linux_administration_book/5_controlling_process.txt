
The kernel’s internal data structures record various pieces of information about
each process. Here are some of the more important of these:
• The process’s address space map
• The current status of the process (sleeping, stopped, runnable, etc.)
• The execution priority of the process
• Information about the resources the process has used
• Information about the files and network ports the process has opened
• The process’s signal mask (a record of which signals are blocked)
• The owner of the process

PID: process ID number
======================
The kernel assigns a unique ID number to every process.

PPID: parent PID
=================
Neither UNIX nor Linux has a system call that initiates a new process running a
particular program. Instead, an existing process must clone itself to create a new
process. The clone can then exchange the program it’s running for a different one

UID and EUID: real and effective user ID
=========================================
A process’s UID is the user identification number of the person who created it, or
more accurately, it is a copy of the UID value of the parent process. 

The EUID is the “effective” user ID, an extra UID used to determine what resources
and files a process has permission to access at any given moment

GID and EGID: real and effective group ID
=========================================
The GID is the group identification number of a process. The GID attribute of a process is largely vestigial. For purposes of access determination, a process can be a member of many groups at once.

Niceness
========
A process’s scheduling priority determines how much CPU time it receives. The
kernel uses a dynamic algorithm to compute priorities, allowing for the amount of
CPU time that a process has recently consumed and the length of time it has been
waiting to run. The kernel also pays attention to an administratively set value
that’s usually called the “nice value” or “niceness,” so called because it tells how
nice you are planning to be to other users of the system. 

THE LIFE CYCLE OF A PROCESS
===========================
1. To create a new process, a process copies itself with the fork system call. fork
creates a copy of the original process; that copy is largely identical to the parent.
The new process has a distinct PID and has its own accounting information.
fork has the unique property of returning two different values. From the child’s
point of view, it returns zero. The parent receives the PID of the newly created
child. Since the two processes are otherwise identical, they must both examine the
return value to figure out which role they are supposed to play

2. After a fork, the child process will often use one of the exec family of system calls
to begin the execution of a new program. These calls change the program that the
process is executing and reset the memory segments to a predefined initial state.
The various forms of exec differ only in the ways in which they specify the command-line
arguments and environment to be given to the new program.

3. When the system boots, the kernel autonomously creates and installs several processes.
The most notable of these is init, which is always process number 1. init is
responsible for executing the system’s startup script.
