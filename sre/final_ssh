Whenever data is sent by a computer to the network, SSH automatically
encrypts (scrambles) it. Then, when the data reaches its intended recipient
automatically decrypts (unscrambles) it. The result is transparent encryption: users
can work normally, unaware that their communications are safely encrypted on the
network.

1. SSH is a client/server based protocol 
2. An SSH server program, typically installed and run by a system administrator, accepts or rejects incoming
connections to its host computer.
3. Users then run SSH client programs, typically on
other computers, to make requests of the SSH server, such as “Please log me in,”
“Please send me a file,” or “Please execute this command.”
4. All communications between clients and servers are securely encrypted and protected from modification.
5. In summary  SSH creates a channel for running a shell on a remote computer, with end-to-end encryption between the two
systems.

SSH Protocol
============
The SSH protocol covers authentication, encryption, and the integrity of data transmitted
over a network

Authentication
--------------
Reliably determines someone’s identity. If you try to log into an account on a
remote computer, SSH asks for digital proof of your identity. If you pass the test,
you may log in; otherwise, SSH rejects the connection

Encryption
----------
Scrambles data so that it is unintelligible except to the intended recipients. This
protects your data as it passes over the network.

Integrity
---------
Guarantees the data traveling over the network arrives unaltered. If a third party
captures and modifies your data in transit, SSH detects this fact.

Examples of Client programs are in : ssh, scp, putty, etc

Major features of SSH
=====================
1. Secure Remote Logins
   Programs like telnet transmit username/password in plain text and reable by a n/w snooper,
   In SSH protocol, the client authenticates you to the remote computer’s SSH server using an encrypted
   connection, meaning that your username and password are encrypted before they leave the local machine.
   The SSH server then logs you in, and your entire login and session is encrypted as it travels between client 
   and server.
2. Secure File Transfer
   ftp is not secure for file transfers, A third party can intercept and read the packets as they travel
   over the network. Using SSH, the file can be transferred securely between machines with a single secure copy command. 
   If the file were named myfile, the command executed on firstaccount.com might be:
   scp myfile metoo@secondaccount.com:
3. Secure Remote Command Execution
   Many SSH clients can run a single remote command if
   you provide it at the end of the command line. This short shell script does the trick:
   #!/bin/sh
  for machine in grape lemon kiwi melon
  do
    ssh $machine /usr/bin/w Execute remote command by ssh
  done
4. Keys and Agents
   SSH has various authentication mechanisms, and the most secure is based on keys rather than passwords. 
   Using keys, together with a program called an authentication agent, SSH can authenticate 
   you to all your computer accounts securely without requiring you to memorize many passwords or enter them repeatedly. It works like this:
   1. In advance (and only once), place special, nonsecure files called public key files
      into your remote computer accounts. These enable your SSH clients (ssh, scp) to
      access your remote accounts.
   2. On your local machine, invoke the ssh-agent program, which runs in the
      background.
   3. Choose the key (or keys) you will need during your login session.
   4. Load the keys into the agent with the ssh-add program. This requires knowledge
      of each key’s secret passphrase.
At this point, you have an ssh-agent program running on your local machine, holding your secret keys in memory. 
You’re now done. You have passwordless access to all your remote accounts that contain your public key files.
Say goodbye to the tedium of retyping passwords! The setup lasts until you log out from the local machine or terminate ssh-agent.

5. Access Control
One can provide limited access through SSH for other users like just run certain application like email

6. Port Forwarding
Suppose you are logged into a machine away from work and want to access the internal
news server at your office, news.yoyodyne.com. The Yoyodyne network is connected
to the Internet, but a network firewall blocks incoming connections to most
ports, particularly port 119, the news port. The firewall does allow incoming SSH
connections. SSH can establish a secure tunnel on an arbitrary local TCP port—say, port 3002—to
the news port on the remote host. The command might look a bit cryptic at this early stage, but here it is:

$ ssh -L 3002:localhost:119 news.yoyodyne.com
This says “ssh, please establish a secure connection from TCP port 3002 on my local
machine to TCP port 119, the news port, on news.yoyodyne.com.” So, in order to
read news securely, configure your news-reading program to connect to port 3002 on
your local machine. The secure tunnel created by ssh automatically communicates
with the news server on news.yoyodyne.com, and the news traffic passing through the
tunnel is protected by encryption.

Known Hosts
===========
The first time an SSH client encounters a new remote machine, it may report that it’s
never seen the machine before, printing a message like the following:
$ ssh -l pat shell.isp.com
The authenticity of host 'shell.isp.com (192.168.0.2)' can't be established.
RSA key fingerprint is 77:a5:69:81:9b:eb:40:76:7b:13:04:a9:6c:f4:9c:5d.
Are you sure you want to continue connecting (yes/no)?
Assuming you respond yes (the most common response), the client continues:
Warning: Permanently added 'shell.isp.com,192.168.0.2' (RSA) to the list of known
hosts.
This message appears only the first time you contact a particular remote host. The
message is a security feature related to SSH’s concept of known hosts.

If authentication of the server fails, various things may happen depending on the reason
for failure and the SSH configuration. Typically a warning appears on the screen,
ranging from a repeat of the known-hosts message:
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)?
to more dire words:
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that the RSA host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
77:a5:69:81:9b:eb:40:76:7b:13:04:a9:6c:f4:9c:5d.
Please contact your system administrator.
Add correct host key in /home/smith/.ssh/known_hosts to get rid of this message.
Offending key in /home/smith/.ssh/known_hosts:36

Key Management
==============
User's can be authenticated using keys rather than username/password

Passwords have following drawbacks:-
1.  In order for a password to be secure, it should be long and random, but such
passwords are hard to memorize
2. A password sent across the network, even protected by an SSH secure channel,
can be captured when it arrives on the remote host if that host has been compromised.
3. Most operating systems support only a single password per account. For shared
accounts (e.g., a superuser account), this presents difficulties:
— Password changes are inconvenient because the new password must be communicated
to all people with access to the account.
— Tracking usage of the account becomes difficult because the operating system
doesn’t distinguish between the different users of the account.
To address these problems, SSH supports public-key authentication: instead of relying
on the password scheme of the host operating system,

A key is a digital identity. It’s a unique string of binary data that means “This is me,
honestly, I swear.” And with a little cryptographic magic, your SSH client can prove
to a server that its key is genuine, and you are really you.

How does it work?
==================
1. An SSH identity uses a pair of keys, one private and one public.
2. The private key is a closely guarded secret only you have. Your SSH clients use it to prove your identity to servers.
3. The public key is, like the name says, public. You place it freely into your accounts on SSH server machines. 
   During authentication, the SSH client and server have a little conversation about your private and public key. If they match (according
   to a cryptographic test), your identity is proven, and authentication succeeds.

Steps:-
=====
1. Your client says, “Hey server, I’d like to connect by SSH to an account on your
system, specifically, the account owned by user smith.”
2. The server says, “Well, maybe. First, I challenge you to prove your identity!”
And the server sends some data, known as a challenge, to the client
3. Your client says, “I accept your challenge. Here is proof of my identity. I made it
myself by mathematically using your challenge and my private key.” This
response to the server is called an authenticator.
4. The server says, “Thanks for the authenticator. I will now examine the smith
account to see if you may enter.” Specifically, the server checks smith’s public
keys to see if the authenticator “matches” any of them. (The “match” is another
cryptographic operation.) If so, the server says, “OK, come on in!” Otherwise,
the authentication fails.

generate keys using  ssh-keygen
ssh-keygen then creates your local SSH directory (~/.ssh for OpenSSH or ~/.ssh2 for
Tectia) if it doesn’t already exist, and stores the private and public components of
the generated key in two files there.



