Whenever data is sent by a computer to the network, SSH automatically
encrypts (scrambles) it. Then, when the data reaches its intended recipient
automatically decrypts (unscrambles) it. The result is transparent encryption: users
can work normally, unaware that their communications are safely encrypted on the
network.

1. SSH is a client/server based protocol 
2. An SSH server program, typically installed and run by a system administrator, accepts or rejects incoming
connections to its host computer.
3. Users then run SSH client programs, typically on
other computers, to make requests of the SSH server, such as “Please log me in,”
“Please send me a file,” or “Please execute this command.”
4. All communications between clients and servers are securely encrypted and protected from modification.
5. In summary  SSH creates a channel for running a shell on a remote computer, with end-to-end encryption between the two
systems.

SSH Protocol
============
The SSH protocol covers authentication, encryption, and the integrity of data transmitted
over a network

Authentication
--------------
Reliably determines someone’s identity. If you try to log into an account on a
remote computer, SSH asks for digital proof of your identity. If you pass the test,
you may log in; otherwise, SSH rejects the connection

Encryption
----------
Scrambles data so that it is unintelligible except to the intended recipients. This
protects your data as it passes over the network.

Integrity
---------
Guarantees the data traveling over the network arrives unaltered. If a third party
captures and modifies your data in transit, SSH detects this fact.

Examples of Client programs are in : ssh, scp, putty, etc

Major features of SSH
=====================
1. Secure Remote Logins
   Programs like telnet transmit username/password in plain text and reable by a n/w snooper,
   In SSH protocol, the client authenticates you to the remote computer’s SSH server using an encrypted
   connection, meaning that your username and password are encrypted before they leave the local machine.
   The SSH server then logs you in, and your entire login and session is encrypted as it travels between client 
   and server.
2. Secure File Transfer
   ftp is not secure for file transfers, A third party can intercept and read the packets as they travel
   over the network. Using SSH, the file can be transferred securely between machines with a single secure copy command. 
   If the file were named myfile, the command executed on firstaccount.com might be:
   scp myfile metoo@secondaccount.com:
3. Secure Remote Command Execution
   Many SSH clients can run a single remote command if
   you provide it at the end of the command line. This short shell script does the trick:
   #!/bin/sh
  for machine in grape lemon kiwi melon
  do
    ssh $machine /usr/bin/w Execute remote command by ssh
  done
4. Keys and Agents
   SSH has various authentication mechanisms, and the most secure is based on keys rather than passwords. 
   Using keys, together with a program called an authentication agent, SSH can authenticate 
   you to all your computer accounts securely without requiring you to memorize many passwords or enter them repeatedly. It works like this:
   1. In advance (and only once), place special, nonsecure files called public key files
      into your remote computer accounts. These enable your SSH clients (ssh, scp) to
      access your remote accounts.
   2. On your local machine, invoke the ssh-agent program, which runs in the
      background.
   3. Choose the key (or keys) you will need during your login session.
   4. Load the keys into the agent with the ssh-add program. This requires knowledge
      of each key’s secret passphrase.
At this point, you have an ssh-agent program running on your local machine, holding your secret keys in memory. 
You’re now done. You have passwordless access to all your remote accounts that contain your public key files.
Say goodbye to the tedium of retyping passwords! The setup lasts until you log out from the local machine or terminate ssh-agent.

5. Access Control
One can provide limited access through SSH for other users like just run certain application like email

6. Port Forwarding
Suppose you are logged into a machine away from work and want to access the internal
news server at your office, news.yoyodyne.com. The Yoyodyne network is connected
to the Internet, but a network firewall blocks incoming connections to most
ports, particularly port 119, the news port. The firewall does allow incoming SSH
connections. SSH can establish a secure tunnel on an arbitrary local TCP port—say, port 3002—to
the news port on the remote host. The command might look a bit cryptic at this early stage, but here it is:

$ ssh -L 3002:localhost:119 news.yoyodyne.com
This says “ssh, please establish a secure connection from TCP port 3002 on my local
machine to TCP port 119, the news port, on news.yoyodyne.com.” So, in order to
read news securely, configure your news-reading program to connect to port 3002 on
your local machine. The secure tunnel created by ssh automatically communicates
with the news server on news.yoyodyne.com, and the news traffic passing through the
tunnel is protected by encryption.

Known Hosts
===========
The first time an SSH client encounters a new remote machine, it may report that it’s
never seen the machine before, printing a message like the following:
$ ssh -l pat shell.isp.com
The authenticity of host 'shell.isp.com (192.168.0.2)' can't be established.
RSA key fingerprint is 77:a5:69:81:9b:eb:40:76:7b:13:04:a9:6c:f4:9c:5d.
Are you sure you want to continue connecting (yes/no)?
Assuming you respond yes (the most common response), the client continues:
Warning: Permanently added 'shell.isp.com,192.168.0.2' (RSA) to the list of known
hosts.
This message appears only the first time you contact a particular remote host. The
message is a security feature related to SSH’s concept of known hosts.

If authentication of the server fails, various things may happen depending on the reason
for failure and the SSH configuration. Typically a warning appears on the screen,
ranging from a repeat of the known-hosts message:
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)?
to more dire words:
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that the RSA host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
77:a5:69:81:9b:eb:40:76:7b:13:04:a9:6c:f4:9c:5d.
Please contact your system administrator.
Add correct host key in /home/smith/.ssh/known_hosts to get rid of this message.
Offending key in /home/smith/.ssh/known_hosts:36

Key Management
==============
User's can be authenticated using keys rather than username/password

Passwords have following drawbacks:-
1.  In order for a password to be secure, it should be long and random, but such
passwords are hard to memorize
2. A password sent across the network, even protected by an SSH secure channel,
can be captured when it arrives on the remote host if that host has been compromised.
3. Most operating systems support only a single password per account. For shared
accounts (e.g., a superuser account), this presents difficulties:
— Password changes are inconvenient because the new password must be communicated
to all people with access to the account.
— Tracking usage of the account becomes difficult because the operating system
doesn’t distinguish between the different users of the account.
To address these problems, SSH supports public-key authentication: instead of relying
on the password scheme of the host operating system,

A key is a digital identity. It’s a unique string of binary data that means “This is me,
honestly, I swear.” And with a little cryptographic magic, your SSH client can prove
to a server that its key is genuine, and you are really you.

How does it work?
==================
1. An SSH identity uses a pair of keys, one private and one public.
2. The private key is a closely guarded secret only you have. Your SSH clients use it to prove your identity to servers.
3. The public key is, like the name says, public. You place it freely into your accounts on SSH server machines. 
   During authentication, the SSH client and server have a little conversation about your private and public key. If they match (according
   to a cryptographic test), your identity is proven, and authentication succeeds.

Steps:-
=====
1. Your client says, “Hey server, I’d like to connect by SSH to an account on your
system, specifically, the account owned by user smith.”
2. The server says, “Well, maybe. First, I challenge you to prove your identity!”
And the server sends some data, known as a challenge, to the client
3. Your client says, “I accept your challenge. Here is proof of my identity. I made it
myself by mathematically using your challenge and my private key.” This
response to the server is called an authenticator.
4. The server says, “Thanks for the authenticator. I will now examine the smith
account to see if you may enter.” Specifically, the server checks smith’s public
keys to see if the authenticator “matches” any of them. (The “match” is another
cryptographic operation.) If so, the server says, “OK, come on in!” Otherwise,
the authentication fails.

generate keys using  ssh-keygen
===============================
ssh-keygen then creates your local SSH directory (~/.ssh for OpenSSH or ~/.ssh2 for
Tectia) if it doesn’t already exist, and stores the private and public components of
the generated key in two files there.

Installing OpenSSH Keys with ssh-copy-id
========================================
OpenSSH includes a program, ssh-copy-id, that installs a public key automatically on
a remote server with a single command, placing it into ~/.ssh/authorized_keys:

Public-key authentication is more secure than password authentication because:
==============================================================================
1. It requires two secret components—the identity file on disk, and the passphrase
in your head—so both must be captured in order for an adversary to access your
account. Password authentication requires only one component, the password,
which might be easier to steal.
2. Neither the passphrase nor the key is sent to the remote host, just the authenticator
discussed earlier. Therefore, no secret information is transmitted off the
client machine.
3. Machine-generated cryptographic keys are infeasible to guess. Human-generated
passwords are routinely cracked by a password-guessing technique called a
dictionary attack. A dictionary attack may be mounted on the passphrase as well,
but this requires stealing the private-key file first.
A host’s security can be greatly increased by disabling password authentication altogether
and permitting only SSH connections by key.
ssh-copy-id -i key_file [user@]server_name

What happens if key changes
===========================
Once ssh-keygen is run on a client machine, it's public key changes and all servers having the public key of this
client should change.

ssh-agent
=========
1. ssh-agent is a program that keeps private keys in memory and provides authentication If you preload an agent with private keys at the beginning
of a login session, your SSH clients won’t prompt for passphrases. Instead, they communicate with the agent as needed. 
The effects of the agent last until you terminate  the agent, usually just before logging out.
2. SSH clients comunicate with the ssh-agent via local sockets or named pipe whose filename is stored in
an environment variable, so all clients (and all other processes) within your login session
have access to the agent.
3. ssh-agent $SHELL
Creates a shell which has access to the ssh-agent

Once the agent is running, it’s time to load private keys into it using the ssh-add program.
By default, ssh-add loads the key from your default identity file:
$ ssh-add
Enter passphrase for /home/you/.ssh/id_dsa: ********
Identity added: /home/you/.ssh/id_dsa (/home/you/.ssh/id_dsa)
Now ssh and scp can connect to remote hosts without prompting for your passphrase.
Figure 2-3 shows the process.

ssh-add
=======
Decrypts private key and stores in agent.
Identity file(public and private keys encrypted) => ssh-add decrypts the private key and stores in agent(plain text) => 
ssh then this key for authenticating..

It can do other things too..

To load a key other than your default
identity into the agent, provide the filename as an argument to ssh-add:
$ ssh-add my-other-key-file
You can also list the keys the agent currently holds:
$ ssh-add -l
delete a key from the agent in memory:
$ ssh-add -d name-of-key-file
or delete all keys from the agent in memory:
$ ssh-add -D

SSH server
==========
sshd reads its configuration file at startup. Therefore, if you modify the file while the
server is running, the changes don’t affect the server. You must force the server to
reread the file in order to accept the changes. This is done by sending a SIGHUP
signal to the server process. The pid of the server is found in a file, usually /var/run/
sshd.pid 

 kill -HUP `pidof sshd`

server key management
=====================
The host key of sshd uniquely identifies a server to SSH clients. The host key is
stored in a pair of files, one containing the private key and the other the public key
Each private key has a corresponding public key, stored in a second file with the
same name but with .pub appended.

You may also configure sshd to bind its listening port on a particular network interface.
By default, the port is bound on all active network interfaces on the host. The
ListenAddress keyword limits sshd to listen only on specific interfaces; the default
value is 0.0.0.0.

sshd normally runs as a daemon, listening for incoming connection requests, and
forking whenever it accepts a connection from a client. This spawns a separate child
process (a copy of the parent sshd process) to handle each session. The child process
exits when the session ends.

Alternatively, the server may be invoked by inetd or xinetd, like many other network
daemons. In this case, the general-purpose network daemon listens for and accepts
the SSH connections. It then starts a new instance of sshd for each session with the
already-connected socket attached to the standard input, output, and error streams
of sshd. Each sshd invocation is responsible for a single session.

If you prefer this behavior, place an appropriate line in the inetd or xinetd configuration
file to describe the SSH service, invoking sshd with the –i command-line option.
For inetd, add a single line to /etc/inetd.conf:
ssh stream tcp nowait root /usr/local/sbin/sshd sshd -i

By default, the OpenSSH server restarts itself after it accepts each connection from a
client, and forks to create a separate child process to handle the session.† Relative
pathnames can’t be used for server restarts, since sshd changes its working directory
shortly after it begins running.

The parent process (i.e., the one that listens for
incoming connections) sends a copy of its configuration and the SSH-1 server key (if
one is used) via another socket to the restarted child process, which knows to read
the data because of the same –R option. The child process then proceeds to handle
the session normally.

If OpenSSH is started by inetd or xinetd, then there is no need to restart the SSH
server, because a new instance of sshd is started by inetd/xinetd for each connection.

Keep Alive feature(detect dead connections)
===================
The keepalive feature (TCPKeepAlive in OpenSSH, KeepAlive in Tectia) is concerned
with recognizing when a connection has failed. Suppose a client establishes an SSH
connection, and sometime later, the client host crashes abruptly. If the SSH server
has no reason to send unsolicited messages to the client, it may never notice the halfdead
TCP connection to its partner, and the sshd remains around indefinitely, using
up system resources such as memory and a process slot (and making the sysadmin’s
ps output messy).

Idle connections
================
 If an SSH connection
is established between a server and a client, but no data passes over the
connection for a long time, what should the server do: keep the connection, or terminate
it?
The IdleTimeout keyword tells the server what to do if a connection is idle, i.e., if the
user doesn’t transmit any data in a given period. If IdleTimeout is zero (the default),
the server does nothing, leaving idle connections intact:
# Tectia
IdleTimeout 0
Otherwise, the server terminates the connection after a specified interval of idleness.
The time value can specify units, e.g., three hours:
# Tectia
IdleTimeout 3H
